# /dev - Minimal Dev Workflow

## Overview

A freshly designed lightweight development workflow with no legacy baggage, focused on delivering high-quality code fast.

## Flow

```
/dev trigger
  ↓
AskUserQuestion (requirements clarification)
  ↓
codeagent analysis (plan mode + UI auto-detection)
  ↓
dev-plan-generator (create dev doc)
  ↓
codeagent concurrent development (intelligent backend selection)
  ↓
codeagent testing & verification (≥90% coverage)
  ↓
Done (generate summary)
```

## The 6 Steps

### 1. Clarify Requirements
- Use **AskUserQuestion** to ask the user directly
- No scoring system, no complex logic
- 2–3 rounds of Q&A until the requirement is clear

### 2. codeagent Analysis & UI Detection
- Call codeagent to analyze the request in plan mode style
- Extract: core functions, technical points, task list with complexity ratings
- UI auto-detection: needs UI work when task involves style assets (.css, .scss, styled-components, CSS modules, tailwindcss) OR frontend component files (.tsx, .jsx, .vue); output yes/no plus evidence

### 3. Generate Dev Doc
- Call the **dev-plan-generator** agent
- Produce a single `dev-plan.md`
- Append a dedicated UI task when Step 2 marks `needs_ui: true`
- Include: task breakdown, file scope, dependencies, test commands

### 4. Concurrent Development
- Work from the task list in dev-plan.md
- Use codeagent per task with intelligent backend selection:
  - Simple/Medium tasks → `--backend claude` (fast, cost-effective)
  - Complex tasks → `--backend codex` (deep reasoning)
  - UI tasks → `--backend gemini` (enforced)
- Backend selected automatically based on task complexity rating
- Independent tasks → run in parallel
- Conflicting tasks → run serially

### 5. Testing & Verification
- Each codeagent task:
  - Implements the feature
  - Writes tests
  - Runs coverage
  - Reports results (≥90%)

### 6. Complete
- Summarize task status
- Record coverage

## Usage

```bash
/dev "Implement user login with email + password"
```

**No options**, fixed workflow, works out of the box.

## Output Structure

```
.claude/specs/{feature_name}/
└──  dev-plan.md      # Dev document generated by agent
```

Only one file—minimal and clear.

## Core Components

### Tools
- **AskUserQuestion**: interactive requirement clarification
- **codeagent skill**: analysis, development, testing; supports `--backend` for claude/codex/gemini
- **dev-plan-generator agent**: generate dev doc with complexity ratings (subagent via Task tool, saves context)

## Intelligent Backend Selection
- **Complexity-based routing**: Tasks are rated as simple/medium/complex based on functional requirements (NOT code volume)
  - Simple: Follows existing patterns, deterministic logic → claude
  - Medium: Requires design decisions, multiple scenarios → claude
  - Complex: Architecture design, algorithms, deep domain knowledge → codex
  - UI: Style/component work → gemini (enforced)
- **Flow impact**: Step 2 analyzes complexity; Step 3 includes complexity ratings in dev-plan.md; Step 4 auto-selects backend
- **Implementation**: Orchestrator reads complexity field and invokes codeagent skill with appropriate backend parameter

## Key Features

### ✅ Fresh Design
- No legacy project residue
- No complex scoring logic
- No extra abstraction layers

### ✅ Minimal Orchestration
- Orchestrator controls the flow directly
- Only three tools/components
- Steps are straightforward

### ✅ Concurrency
- Tasks split based on natural functional boundaries
- Auto-detect dependencies and conflicts
- codeagent executes independently with optimal backend

### ✅ Quality Assurance
- Enforces 90% coverage
- codeagent tests and verifies its own work
- Automatic retry on failure

## Example

```bash
# Trigger
/dev "Add user login feature"

# Step 1: Clarify requirements
Q: What login methods are supported?
A: Email + password
Q: Should login be remembered?
A: Yes, use JWT token

# Step 2: codeagent analysis
Output:
- Core: email/password login + JWT auth
- Task 1: Backend API (complexity: medium)
- Task 2: Password hashing (complexity: simple)
- Task 3: Frontend form (complexity: simple)
UI detection: needs_ui = true (tailwindcss classes in frontend form)

# Step 3: Generate doc
dev-plan.md generated with complexity ratings ✓

# Step 4-5: Concurrent development (intelligent backend selection)
[task-1] Backend API (claude, medium) → tests → 92% ✓
[task-2] Password hashing (claude, simple) → tests → 95% ✓
[task-3] Frontend form (gemini, UI) → tests → 91% ✓
```

## Directory Structure

```
dev-workflow/
├── README.md                          # This doc
├── commands/
│   └── dev.md                         # /dev workflow orchestrator definition
└── agents/
    └── dev-plan-generator.md          # Dev plan document generator agent
```

Minimal structure, only three files.

## When to Use

✅ **Good for**:
- Any feature size
- Fast iterations
- High test coverage needs
- Wanting concurrent speed-up

## Design Principles

1. **KISS**: keep it simple
2. **Disposable**: no persistent config
3. **Quality first**: enforce 90% coverage
4. **Concurrency first**: leverage codeagent
5. **No legacy baggage**: clean-slate design

---

**Philosophy**: zero tolerance for complexity—ship the smallest usable solution, like Linus would.
