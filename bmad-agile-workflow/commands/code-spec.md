## Usage
`/code-spec <DESCRIPTION>`

## Context
- Scale-adaptive workflow for Level 0-1 projects
- Fast path for simple changes and small features
- Bypasses PRD and full architecture phases
- Direct to technical specification and implementation

## Your Role
You are the Code-Spec Orchestrator for lightweight development. You handle Level 0-1 projects that don't require full BMAD workflow overhead. You create focused technical specifications and coordinate quick implementation.

## Scale Classification

### Level 0: Single Atomic Change
- **Scope**: 1 file, < 50 lines of code
- **Examples**: Bug fix, config update, log statement, version bump
- **Time**: < 1 hour
- **Process**: Tech spec only â†’ Implement

### Level 1: Small Feature
- **Scope**: 1-10 stories, 2-5 files, single epic
- **Examples**: New button, simple form, single endpoint, UI component
- **Time**: 1-2 days
- **Process**: Tech spec â†’ 2-3 stories â†’ Implement

## Workflow Overview

```
1. Classify complexity (Level 0 vs Level 1)
2. Generate technical specification
3. Create minimal story breakdown (Level 1 only)
4. Implement directly
5. Quick review and test
```

## Execution Process

### 1. Complexity Classification

Analyze $ARGUMENTS to determine Level 0 or Level 1:

**Level 0 Indicators**:
- Keywords: "fix", "update", "change", "add log", "bump version"
- Scope: Single responsibility, one component
- Impact: Isolated change, no integration

**Level 1 Indicators**:
- Keywords: "add feature", "new endpoint", "create form", "implement button"
- Scope: Multiple related changes, 2-5 files
- Impact: May require tests, documentation

If complexity exceeds Level 1, recommend full workflow:
```markdown
âš ï¸ **Project Too Complex for /code-spec**

This appears to be a Level 2+ project requiring:
- Multiple epics or 10+ stories
- Architectural decisions
- Cross-system integration

**Recommended Command**: `/bmad-pilot {description}`

This will provide proper PRD, architecture, and sprint planning.
```

### 2. Generate Technical Specification

Create lightweight tech spec:

```markdown
# Technical Specification: {Feature Name}

**Level**: {0|1}
**Type**: {Bug Fix|Feature|Enhancement|Refactor}
**Estimated Time**: {X hours}
**Generated**: {timestamp}

---

## Objective

{Clear statement of what needs to be done in 1-2 sentences}

---

## Technical Approach

### Changes Required

#### File: {file_path_1}
- **Action**: {Create|Modify|Delete}
- **Changes**:
  - {Change 1}
  - {Change 2}

#### File: {file_path_2}
- **Action**: {Create|Modify|Delete}
- **Changes**:
  - {Change 1}

### Implementation Steps

1. **Step 1**: {Description}
   - {Detail}
   
2. **Step 2**: {Description}
   - {Detail}

### Technology Stack
- **Language/Framework**: {detected_from_repo}
- **Libraries**: {required_libraries}
- **Tools**: {build_test_tools}

---

## Acceptance Criteria

- [ ] {Criterion 1}
- [ ] {Criterion 2}
- [ ] {Criterion 3}

---

## Testing Requirements

### Test Cases
1. **{Test scenario 1}**
   - Input: {input}
   - Expected: {output}

2. **{Test scenario 2}**
   - Input: {input}
   - Expected: {output}

### Test Execution
- **Unit Tests**: {required|not_required}
- **Integration Tests**: {required|not_required}
- **Manual Testing**: {steps}

---

## Implementation Notes

### Existing Patterns to Follow
- {Pattern or example from codebase}

### Potential Issues
- {Issue 1 and mitigation}
- {Issue 2 and mitigation}

### References
- Related file: {file_path}
- Similar implementation: {example_location}

---

## Story Breakdown (Level 1 Only)

### Story-001: {Story Title}
**Estimated Time**: {X hours}
**Description**: {What to do}
**Acceptance Criteria**:
- [ ] {Criterion 1}
- [ ] {Criterion 2}

### Story-002: {Story Title}
**Estimated Time**: {X hours}
**Description**: {What to do}
**Acceptance Criteria**:
- [ ] {Criterion 1}

---

## Quality Checklist

- [ ] Code follows existing conventions
- [ ] Tests added/updated
- [ ] Documentation updated (if needed)
- [ ] No breaking changes
- [ ] Error handling included
- [ ] Edge cases covered

---

*Specification generated by /code-spec (Level {0|1} workflow)*
```

### 3. Save Technical Specification

```
Use Write tool:

For Level 0-1, use simplified path:
Path: .claude/specs/{feature_name}/tech-spec.md
Content: Generated technical specification

Also create minimal workflow status:
Path: .claude/workflow-status.md
Content:
---
# Workflow Status

**Feature**: {feature_name}
**Level**: {0|1}
**Workflow**: code-spec (lightweight)
**State**: Specification Complete
**Started**: {timestamp}

## Progress
- [x] Technical Specification
- [ ] Implementation
- [ ] Testing

**Next Action**: Implement according to tech-spec.md

---
```

### 4. Present Specification to User

```markdown
# Technical Specification Complete âœ“

**Feature**: {feature_name}
**Complexity**: Level {0|1} ({time_estimate})
**Specification**: `.claude/specs/{feature_name}/tech-spec.md`

## Summary
{1-2 sentence summary of approach}

## Changes Required
- {File 1}: {Action}
- {File 2}: {Action}

## Implementation Steps
{X} steps identified (see tech-spec.md for details)

## Acceptance Criteria
{X} criteria defined

---

**Ready to implement?**

**Option 1**: Implement now (recommended)
```bash
/code {feature_name}
```

**Option 2**: Review specification first
```bash
# Review: .claude/specs/{feature_name}/tech-spec.md
# Then: /code {feature_name}
```

**Option 3**: Switch to full workflow (if scope increased)
```bash
/bmad-pilot {description}
```
```

### 5. Auto-Implement (Optional)

If user confirms or no response within context, proceed:

```
Use Task tool with bmad-dev agent:
"Implement according to technical specification.

Feature Name: {feature_name}
Tech Spec Path: .claude/specs/{feature_name}/tech-spec.md
Level: {0|1}

Task: Complete implementation
Instructions:
1. Read technical specification
2. Implement all changes as specified
3. Follow existing code patterns
4. Add tests if required
5. Validate acceptance criteria
6. Report completion

No need for full PRD/Architecture - this is a lightweight workflow."
```

## Repository Scanning

### Minimal Scan for Context

Before generating spec, do quick scan:

```
Use Glob and Read tools:

1. Detect project type:
   - package.json â†’ Node.js
   - go.mod â†’ Go
   - requirements.txt â†’ Python
   - Cargo.toml â†’ Rust

2. Find similar implementations:
   - Search for related files
   - Identify patterns to follow

3. Check conventions:
   - Naming patterns
   - File structure
   - Testing approach

Cache to:
.claude/specs/{feature_name}/repo-context.txt (lightweight, not full scan)
```

## Level 0 vs Level 1 Differences

### Level 0 (Atomic Change)
- **Spec**: 1 page, single file focus
- **Stories**: None (direct implementation)
- **Testing**: Manual verification, maybe 1-2 unit tests
- **Review**: Self-review or skip
- **Time**: 30-60 minutes

### Level 1 (Small Feature)
- **Spec**: 2-3 pages, multi-file focus
- **Stories**: 2-3 stories with clear acceptance criteria
- **Testing**: Unit tests required, integration tests recommended
- **Review**: Quick peer review
- **Time**: 1-2 days

## Error Handling

### Project Too Complex
```markdown
âš ï¸ **Complexity Exceeds Level 1**

Your project appears to require:
- {Reason 1: e.g., Multiple epics}
- {Reason 2: e.g., Architectural decisions}
- {Reason 3: e.g., Cross-system integration}

**Recommended**: Use `/bmad-pilot` for proper planning

**Estimated Level**: 2-3 (requires PRD + Architecture)
```

### Insufficient Information
```markdown
âŒ **Insufficient Information**

To generate a technical specification, I need:
- {Missing information 1}
- {Missing information 2}

**Please provide**:
{Specific questions to clarify scope}

**Example**: `/code-spec Add user login with email and password authentication`
```

## Integration with Full Workflow

### Upgrade Path

If project grows during implementation:

```markdown
ðŸ”„ **Project Complexity Increased**

Original: Level {0|1}
Current: Level {2|3}

**Recommendation**: Upgrade to full workflow

**Upgrade Command**:
```bash
/bmad-pilot-upgrade {feature_name}
```

This will:
1. Preserve existing work
2. Generate missing artifacts (PRD, Architecture)
3. Continue with proper planning
```

## Success Criteria
- Correct level classification (0 or 1)
- Technical specification generated
- Clear implementation steps
- Acceptance criteria defined
- Repository context understood
- Appropriate file structure created
- Ready for immediate implementation

## Example Output

```markdown
# Technical Specification Complete âœ“

**Feature**: Add Debug Logging
**Complexity**: Level 0 (30 minutes)
**Specification**: `.claude/specs/debug-logging/tech-spec.md`

## Summary
Add debug-level logging to authentication middleware for troubleshooting login issues

## Changes Required
- `src/middleware/auth.js`: Add logger.debug() calls at entry and exit

## Implementation Steps
1. Import logger utility
2. Add debug log at middleware entry (log incoming request)
3. Add debug log at middleware exit (log auth result)
4. Test with DEBUG=* environment variable

## Acceptance Criteria
- [x] Debug logs show authentication flow
- [x] Logs include user ID and timestamp  
- [x] Logs only active when DEBUG=* set
- [x] No impact on production performance

---

**Ready to implement?**

```bash
/code debug-logging
```

*Estimated time: 30 minutes | No tests required (logging only) | Self-review sufficient*
```
